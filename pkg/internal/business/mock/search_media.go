// Code generated by MockGen. DO NOT EDIT.
// Source: search_media.go

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	business "github.com/NawafSwe/media-scout-service/pkg/internal/business"
	gomock "github.com/golang/mock/gomock"
)

// MockmediaRepository is a mock of mediaRepository interface.
type MockmediaRepository struct {
	ctrl     *gomock.Controller
	recorder *MockmediaRepositoryMockRecorder
}

// MockmediaRepositoryMockRecorder is the mock recorder for MockmediaRepository.
type MockmediaRepositoryMockRecorder struct {
	mock *MockmediaRepository
}

// NewMockmediaRepository creates a new mock instance.
func NewMockmediaRepository(ctrl *gomock.Controller) *MockmediaRepository {
	mock := &MockmediaRepository{ctrl: ctrl}
	mock.recorder = &MockmediaRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockmediaRepository) EXPECT() *MockmediaRepositoryMockRecorder {
	return m.recorder
}

// InsertMedia mocks base method.
func (m *MockmediaRepository) InsertMedia(ctx context.Context, media business.MediaResult) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertMedia", ctx, media)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMedia indicates an expected call of InsertMedia.
func (mr *MockmediaRepositoryMockRecorder) InsertMedia(ctx, media interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMedia", reflect.TypeOf((*MockmediaRepository)(nil).InsertMedia), ctx, media)
}

// MockmediaFetcher is a mock of mediaFetcher interface.
type MockmediaFetcher struct {
	ctrl     *gomock.Controller
	recorder *MockmediaFetcherMockRecorder
}

// MockmediaFetcherMockRecorder is the mock recorder for MockmediaFetcher.
type MockmediaFetcherMockRecorder struct {
	mock *MockmediaFetcher
}

// NewMockmediaFetcher creates a new mock instance.
func NewMockmediaFetcher(ctrl *gomock.Controller) *MockmediaFetcher {
	mock := &MockmediaFetcher{ctrl: ctrl}
	mock.recorder = &MockmediaFetcherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockmediaFetcher) EXPECT() *MockmediaFetcherMockRecorder {
	return m.recorder
}

// FetchMediaByTerm mocks base method.
func (m *MockmediaFetcher) FetchMediaByTerm(ctx context.Context, term string, limit int) (business.MediaResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchMediaByTerm", ctx, term, limit)
	ret0, _ := ret[0].(business.MediaResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchMediaByTerm indicates an expected call of FetchMediaByTerm.
func (mr *MockmediaFetcherMockRecorder) FetchMediaByTerm(ctx, term, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchMediaByTerm", reflect.TypeOf((*MockmediaFetcher)(nil).FetchMediaByTerm), ctx, term, limit)
}

// Mocklogger is a mock of logger interface.
type Mocklogger struct {
	ctrl     *gomock.Controller
	recorder *MockloggerMockRecorder
}

// MockloggerMockRecorder is the mock recorder for Mocklogger.
type MockloggerMockRecorder struct {
	mock *Mocklogger
}

// NewMocklogger creates a new mock instance.
func NewMocklogger(ctrl *gomock.Controller) *Mocklogger {
	mock := &Mocklogger{ctrl: ctrl}
	mock.recorder = &MockloggerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mocklogger) EXPECT() *MockloggerMockRecorder {
	return m.recorder
}

// ErrorContext mocks base method.
func (m *Mocklogger) ErrorContext(ctx context.Context, msg string, args ...any) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, msg}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "ErrorContext", varargs...)
}

// ErrorContext indicates an expected call of ErrorContext.
func (mr *MockloggerMockRecorder) ErrorContext(ctx, msg interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, msg}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ErrorContext", reflect.TypeOf((*Mocklogger)(nil).ErrorContext), varargs...)
}
